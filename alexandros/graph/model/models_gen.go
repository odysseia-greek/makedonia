// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
)

type AggregatedHealthResponse struct {
	Healthy  bool             `json:"healthy"`
	Time     *string          `json:"time,omitempty"`
	Version  *string          `json:"version,omitempty"`
	Services []*ServiceHealth `json:"services"`
}

type AnalyzeResult struct {
	Author        *string `json:"author,omitempty"`
	Book          *string `json:"book,omitempty"`
	Reference     *string `json:"reference,omitempty"`
	ReferenceLink *string `json:"referenceLink,omitempty"`
	Text          *Rhema  `json:"text,omitempty"`
}

type AnalyzeTextResponse struct {
	Conjugations []*ConjugationResponse `json:"conjugations,omitempty"`
	Texts        []*AnalyzeResult       `json:"texts,omitempty"`
	Rootword     *string                `json:"rootword,omitempty"`
}

type ConjugationResponse struct {
	Rule *string `json:"rule,omitempty"`
	Word *string `json:"word,omitempty"`
}

type DatabaseInfo struct {
	Healthy       bool    `json:"healthy"`
	ClusterName   *string `json:"clusterName,omitempty"`
	ServerName    *string `json:"serverName,omitempty"`
	ServerVersion *string `json:"serverVersion,omitempty"`
}

type Definition struct {
	Grade    int32      `json:"grade"`
	Meanings []*Meaning `json:"meanings"`
}

type EukleidesTopFive struct {
	ServiceName string  `json:"serviceName"`
	Word        string  `json:"word"`
	LastUsed    *string `json:"lastUsed,omitempty"`
	Count       int32   `json:"count"`
}

type EukleidesTopFiveResponse struct {
	TopFive []*EukleidesTopFive `json:"topFive"`
}

type ExpandableSearchQueryInput struct {
	Word     string    `json:"word"`
	Language *Language `json:"language,omitempty"`
	Expand   bool      `json:"expand"`
	Page     *int32    `json:"page,omitempty"`
	Size     *int32    `json:"size,omitempty"`
}

type ExtendedResponse struct {
	Results      []*Lemma             `json:"results"`
	PageInfo     *PageInfo            `json:"pageInfo"`
	SimilarWords []*Hit               `json:"similarWords,omitempty"`
	FoundInText  *AnalyzeTextResponse `json:"foundInText,omitempty"`
}

type HealthResponse struct {
	Healthy bool    `json:"healthy"`
	Time    *string `json:"time,omitempty"`
	Version *string `json:"version,omitempty"`
}

type Hit struct {
	Dutch      *string `json:"dutch,omitempty"`
	English    *string `json:"english,omitempty"`
	Greek      *string `json:"greek,omitempty"`
	LinkedWord *string `json:"linkedWord,omitempty"`
	Original   *string `json:"original,omitempty"`
}

type Lemma struct {
	ID                *string             `json:"id,omitempty"`
	Headword          string              `json:"headword"`
	Normalized        *string             `json:"normalized,omitempty"`
	LinkedWord        *string             `json:"linkedWord,omitempty"`
	PartOfSpeech      *string             `json:"partOfSpeech,omitempty"`
	Article           *string             `json:"article,omitempty"`
	Gender            *string             `json:"gender,omitempty"`
	Noun              *NounInfo           `json:"noun,omitempty"`
	Verb              *VerbInfo           `json:"verb,omitempty"`
	QuickGlosses      []*LocalizedGloss   `json:"quickGlosses"`
	Definitions       []*Definition       `json:"definitions"`
	ModernConnections []*ModernConnection `json:"modernConnections"`
}

type LocalizedGloss struct {
	Language string `json:"language"`
	Gloss    string `json:"gloss"`
}

type Meaning struct {
	Language   string   `json:"language"`
	Definition string   `json:"definition"`
	Notes      []string `json:"notes"`
	Example    *string  `json:"example,omitempty"`
}

type ModernConnection struct {
	Term string  `json:"term"`
	Note *string `json:"note,omitempty"`
}

type NounInfo struct {
	Declension *string `json:"declension,omitempty"`
	Genitive   *string `json:"genitive,omitempty"`
}

type PageInfo struct {
	Page  int32 `json:"page"`
	Size  int32 `json:"size"`
	Total int32 `json:"total"`
}

type Query struct {
}

type Reference struct {
	Work  string `json:"work"`
	Locus string `json:"locus"`
}

type Rhema struct {
	Greek        *string   `json:"greek,omitempty"`
	Section      *string   `json:"section,omitempty"`
	Translations []*string `json:"translations,omitempty"`
}

type SearchQueryInput struct {
	Word     string    `json:"word"`
	Language *Language `json:"language,omitempty"`
	Page     *int32    `json:"page,omitempty"`
	Size     *int32    `json:"size,omitempty"`
}

type SearchResponse struct {
	Results  []*Lemma  `json:"results"`
	PageInfo *PageInfo `json:"pageInfo"`
}

type ServiceHealth struct {
	Name         string        `json:"name"`
	Healthy      bool          `json:"healthy"`
	Version      *string       `json:"version,omitempty"`
	DatabaseInfo *DatabaseInfo `json:"databaseInfo,omitempty"`
}

type VerbInfo struct {
	PrincipalParts []string `json:"principalParts"`
}

type Language string

const (
	LanguageLanguageUnspecified Language = "LANGUAGE_UNSPECIFIED"
	LanguageLangGreek           Language = "LANG_GREEK"
	LanguageLangEnglish         Language = "LANG_ENGLISH"
	LanguageLangDutch           Language = "LANG_DUTCH"
)

var AllLanguage = []Language{
	LanguageLanguageUnspecified,
	LanguageLangGreek,
	LanguageLangEnglish,
	LanguageLangDutch,
}

func (e Language) IsValid() bool {
	switch e {
	case LanguageLanguageUnspecified, LanguageLangGreek, LanguageLangEnglish, LanguageLangDutch:
		return true
	}
	return false
}

func (e Language) String() string {
	return string(e)
}

func (e *Language) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Language(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Language", str)
	}
	return nil
}

func (e Language) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Language) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Language) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
