package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/odysseia-greek/agora/plato/config"
	"github.com/odysseia-greek/makedonia/alexandros/graph/model"
	koinos "github.com/odysseia-greek/makedonia/filippos/gen/go/koinos/v1"
	v1 "github.com/odysseia-greek/makedonia/ptolemaios/gen/go/v1"
)

// Health is the resolver for the health field.
func (r *queryResolver) Health(ctx context.Context) (*model.AggregatedHealthResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)
	sessionId, _ := ctx.Value(config.SessionIdKey).(string)
	return r.Handler.Health(requestID, sessionId)
}

// CounterTopFive is the resolver for the counterTopFive field.
func (r *queryResolver) CounterTopFive(ctx context.Context) (*model.EukleidesTopFiveResponse, error) {
	return r.Handler.TopFive(ctx)
}

// CounterService is the resolver for the counterService field.
func (r *queryResolver) CounterService(ctx context.Context, name string) ([]*model.EukleidesTopFive, error) {
	panic(fmt.Errorf("not implemented: CounterService - counterService"))
}

// CounterSession is the resolver for the CounterSession field.
func (r *queryResolver) CounterSession(ctx context.Context, sessionID string) ([]*model.EukleidesTopFive, error) {
	panic(fmt.Errorf("not implemented: CounterSession - CounterSession"))
}

// Fuzzy is the resolver for the fuzzy field.
func (r *queryResolver) Fuzzy(ctx context.Context, input model.SearchQueryInput) (*model.SearchResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)
	sessionId, _ := ctx.Value(config.SessionIdKey).(string)

	var language koinos.Language
	switch *input.Language {
	case model.LanguageLangGreek:
		language = koinos.Language_LANG_GREEK
	case model.LanguageLangEnglish:
		language = koinos.Language_LANG_ENGLISH
	case model.LanguageLangDutch:
		language = koinos.Language_LANG_DUTCH
	default:
		language = koinos.Language_LANG_GREEK
	}

	request := &koinos.SearchQuery{
		Word:            input.Word,
		Language:        language,
		NumberOfResults: *input.Size,
	}
	return r.Handler.Fuzzy(request, requestID, sessionId)
}

// Exact is the resolver for the exact field.
func (r *queryResolver) Exact(ctx context.Context, input model.ExpandableSearchQueryInput) (*model.ExtendedResponse, error) {
	requestID, _ := ctx.Value(config.HeaderKey).(string)
	sessionId, _ := ctx.Value(config.SessionIdKey).(string)

	var language koinos.Language
	switch *input.Language {
	case model.LanguageLangGreek:
		language = koinos.Language_LANG_GREEK
	case model.LanguageLangEnglish:
		language = koinos.Language_LANG_ENGLISH
	case model.LanguageLangDutch:
		language = koinos.Language_LANG_DUTCH
	default:
		language = koinos.Language_LANG_GREEK
	}

	request := &koinos.SearchQuery{
		Word:            input.Word,
		Language:        language,
		NumberOfResults: *input.Size,
	}
	exactResponse, err := r.Handler.Exact(request, requestID, sessionId)
	if err != nil {
		return nil, err
	}

	var meros []*model.Hit
	var textResponse *model.AnalyzeTextResponse
	if input.Expand {
		fuzzyResponses, _ := r.Handler.Fuzzy(request, requestID, sessionId)

		for _, fuzzy := range fuzzyResponses.Results {
			// Skip the exact match
			if fuzzy.Headword == input.Word {
				continue
			}

			hit := model.Hit{
				English:    nil,
				Greek:      &fuzzy.Headword,
				LinkedWord: fuzzy.LinkedWord,
				Original:   fuzzy.Normalized,
			}

			for _, gloss := range fuzzy.QuickGlosses {
				if gloss.Language == "en" {
					hit.English = &gloss.Gloss
				}
			}
			meros = append(meros, &hit)
		}

		textResponse, _ = r.Handler.Extended(&v1.ExtendedSearch{Word: request.Word}, requestID, sessionId)
	}

	response := &model.ExtendedResponse{
		Results:      exactResponse.Results,
		PageInfo:     exactResponse.PageInfo,
		SimilarWords: meros,
		FoundInText:  textResponse,
	}

	return response, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
